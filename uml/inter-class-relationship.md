#### 继承
类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系

#### 实现
class类实现interface接口（可以是多个）的功能

#### 依赖
就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、、临时性的、非常弱的，但是B类的变化会影响到A

#### 关联
两个类、或者类与接口之间语义级别的一种强依赖关系，比如我和我的朋友

#### 聚合
聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系

#### 组合
组合也是关联关系的一种特例，他体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合

#### 几种关系所表现的强弱程度依次为: 组合 > 聚合 > 关联 > 依赖


#### 泛化关系
```cpp
class Animal {};
class Tigger: public Animal {};
class Dog: public Animal {};
Animal* pAnimal = new Dog;
```

#### 关联关系
- 单项关联
```cpp
class Person {};

class Friend {
  Person* mpPerson;
}
```
- 双向关联
```cpp
class A;

class B {
  A* pA;
}

class A {
  B* pB;
}
```
- 自身关联
```cpp
class C {
  C* pC
}
```

#### 聚合关系
- 关联关系的一种，是强的关联关系
- 聚合是整体和个体的关系
- 聚合关系也是通过实例变量实现的
```cpp
class CPU {};
class Memory {};

class Computer {
  CPU* mpCPU;
  Memory* mpMemory;
}
```

#### 组合关系
```cpp
class Leg {};
class Arm {};

class Person {
  Leg mLeg;
  Arm mArm;
}
```

#### 依赖关系
对于两个相对独立的对象，当一个对象负责构造另一个对象的实例，或者依赖另一个对象的服务时，这两个对象之间主要体现为依赖关系
```cpp
class Car {};
class House {};

class Person {
  void buy(Car& car) {}
  void buy(House* pHouse) {}
}
```

#### UML 线条箭头
- 依赖（Dependency）
- 关联（Association）
- 聚合（Aggregation）
- 合成（Composition）
- 泛化（Generalization）
- 实现（Realization）

#### UML基础
- UML类间关系的种类
- 关联
- 泛化，继承【Generalization】
- 实现【realization】
- 依赖【Dependence】

#### UML类间关系的种类
- 关联 ——————————
- 依赖 --------->
- 流   --------->
- 泛化 --------|>
- 实现 --------|>
- 使用 --------->

#### 关联
UML类图关系中关联描述了系统中对象或实例之间的离散连接，关联带有系统中各个对象之间关系的信息

#### 泛化，继承【Generalization】
UML类图关系中泛化关系是类元的一般描述和具体描述之间的关系，具体描述建立在一般描述的基础之上，并对其进行了扩展

#### 实现【realization】
UML类图关系中实现关系将一种模型元素（如类）与另一种模型元素（如接口）连接起来，其中接口只是行为的说明而不是结构或者实现

#### 实现【realization】
UML类图关系中实现关系将一种模型元素（如类）与另一种模型元素（如接口）连接起来，其中接口只是行为的说明而不是结构或者实现

#### 依赖【Dependence】
UML类图关系中依赖表示两个或多个模型元素之间语义上的关系
- 访问: 允许一个包访问另一个包【access】
- 绑定: 为模板参数赋值以生成一个新的模型元素【bind】
- 调用: 声明一个类调用其他类的方法【call】
- 导出: 声明一个实例可以从另一个实例中到处【derive】
- 友元: 允许一个元素访问另一个元素而不论被访问元素的可见性【friend】
- 引入: 允许一个包访问另一个包的内容并未被访问包的组成部分添加别名【import】
- 实例化: 关于一个类的方法生成了另一个类的实例的生命【instantate】
- 参数: 一个操作和他参数之间的关系【parameter】
- 实现: 说明和其实之间的映射关系【realize】
- 精化: 声明具有两个不同层次上元素的映射关系【refine】
- 发送: 信号发送者和信号接受者之间的关系【send】
- 跟踪: 声明不同模型中元素之间的连接，没有映射精确【trace】
- 使用: 声明使用一个模型元素需要已存在的另一个模型元素，这样才能正确实现使用者的功能（调用，实例化，参数，发送）【use】

#### 约束
UML类图关系中约束可以用来表示各种非局部的关系，如关联路径上的限制

#### 实例
实例是有身份标识的运行实体，即它可以与其他运行实体相区分
在任何时刻都有一个值，随着对实例进行操作值也会被改变

#### 类与类之间存在以下关系
- 泛化(Generalization) 
- 关联(Association) 
- 依赖(Dependency) 
- 聚合(Aggregation) 

- 访问: 允许一个包访问另一个包【access】
- 绑定: 为模板参数赋值以生成一个新的模型元素【bind】
- 调用: 声明一个类调用其他类的方法【call】
- 导出: 声明一个实例可以从另一个实例中到处【derive】
- 友元: 允许一个元素访问另一个元素而不论被访问元素的可见性【friend】
- 引入: 允许一个包访问另一个包的内容并未被访问包的组成部分添加别名【import】
- 实例化: 关于一个类的方法生成了另一个类的实例的生命【instantate】
- 参数: 一个操作和他参数之间的关系【parameter】
- 实现: 说明和其实之间的映射关系【realize】
- 精化: 声明具有两个不同层次上元素的映射关系【refine】
- 发送: 信号发送者和信号接受者之间的关系【send】
- 跟踪: 声明不同模型中元素之间的连接，没有映射精确【trace】
- 使用: 声明使用一个模型元素需要已存在的另一个模型元素，这样才能正确实现使用者的功能（调用，实例化，参数，发送）【use】






