### 索引使用总结
- 一定是为搜索条件的字段创建索引，比如select * from s1 where id = 333;就需要为id加上索引
- 在表中已经有大量数据的情况下，建索引会很慢，且占用硬盘空间，建完后查询速度加快
- innodb表的索引会存放于s1.ibd文件中，而myisam表的索引则会有单独的索引文件table1.MYI

### 索引建立原则
- 选择唯一性索引
- 为经常需要排序、分组和联合操作的字段建立索引
- 为常作为where查询条件的字段建立索引
- 尽量使用前缀来索引
- 限制索引的数目
- 删除不再使用或者很少使用的索引(percona toolkit)
- 大表加索引,要在业务不繁忙期间操作
  - 必须要有主键，如果没有可以做为主键条件的列,创建无关列
  - 经常做为where条件列 order by group by join on的条件(业务:产品功能+用户行为)
  - 最好使用唯一值多的列作为索引，如果索引列重复值较多，可以考虑使用联合索引
  - 列值长度较长的索引列，我们建议使用前缀索引
  - 降低索引条目，一方面不要创建没用索引，不常使用的索引清理，percona toolkit 
  - 索引维护要避开业务繁忙期
  
### 未建立索引时，查询操作规范
- 不允许进行没有查询条件（where），或者查询条件没有建立索引 时候的*类查询
- 避免查询结果集是原表中的大部分数据，即约25％以上
- 由于索引本身失效，统计数据不真实 
- 避免查询条件使用函数在索引列上，或者对索引列进行运算，运算包括(+，-，*，/，! 等) 
- 隐式转换导致索引失效.这一点应当引起重视.也是开发中经常会犯的错误 - 查询条件为int，数据库内为char
- 避免使用 <>  ，not in - 原因：不走索引
- like "%_" 百分号在最前面不走索引
- 单独引用联合索引里非第一位置的索引列.作为条件查询时不走索引

### 其他
- 范围问题：条件不明确，即条件中出现这些符号或关键字：>、>=、<、<=、!= 、between...and...、like
- 尽量选择区分度高的列作为索引
- =和in可以乱序
- 索引列不能参与计算.
- 最左前缀匹配原则
- 排序条件为索引，则select也是索引字段。
- 避免使用select *
- count（1）或count（列）代替count（*）
- 创建表时尽量char代替varchar
- 表的字段顺序固定长度的字段优先
- 组合索引代替多个单利索引（进程使用多个条件查询时）
- 尽量使用短索引
- 使用连接（join）来代替子索引（sub-queries）
- 连表时注意条件类型需要一致
- 索引散列值（重复少）不适合建索引
