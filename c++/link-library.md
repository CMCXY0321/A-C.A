静态连接库就是把(lib)文件中用到的函数代码直接链接进目标程序，程序运行的时候不再需要其它的库文件;
动态链接就是把调用的函数所在文件模块（DLL）和调用函数在文件中的位置等信息链接进目标程序;
程序运行的时候再从DLL中寻找相应函数代码，因此需要相应DLL文件的支持;
静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，则无论你愿不愿意，lib 中的指令都全部被直接包含在最终生成的 EXE 文件中了
但是若使用 DLL，该 DLL 不必被包含在最终 EXE 文件中，EXE 文件执行时可以“动态”地引用和卸载这个与 EXE 独立的 DLL 文件

- 静态链接库
静态链接库的使用需要库的开发者提供生成库的.h头文件和.lib文件
在调用程序的.cpp源代码文件中如下:
```cpp
# include "../lib.h"
# pragma comment(lib, "..//debug//libTest.lib")      //指定与静态库一起链接
```
- 动态链接库
动态链接库的使用需要库的开发者提供生成的.lib文件和.dll文件
DLL内的函数分为两种:
- 外部函数，可供应用程序调用
- DLL内部函数，只能在 DLL 程序使用，应用程序无法调用它们

#### 静态链接库
什么是静态链接呢? 即在链接阶段, 将源文件中用到的库函数与汇编生成的目标文件.o合并生成可执行文件
优点：方便程序移植，因为可执行程序与库函数再无关系，放在如何环境当中都可以执行
缺点：
- 文件太大, 一个全静态方式生成的简单 print 文件都有857K
- 而动态链接生成的一样的可执行文件却只要8.4K
- 对于静态编译的程序1和程序2，都应用库 staticMath
- 在内存中就又两份相同的staticＭath目标文件, 很浪费空间, 一旦程序数量过多就很可能会内存不足

#### 编译：
```c
// 生成静态库(c)
gcc -static -o print print.c

// 生成静态库(c++)
g++ -c add.cpp

// ar命令进一步生成库libadd.a
ar -crv libadd.a add.o
```

#### 动态链接库
优缺点：
- 两个程序只应用一个库，这个目标文件在内存中只有一份，供所有程序使用
- 并且在程序运行过程中动态调用库文件，很方便，又不占空间，
- 可移植性太差，运行环境不同，动态库存放的位置不一样，可能导致程序运行失败

```c
// 生成一个动态库
g++ -fPIC -shared -o libadd.so add.cpp
// 动态链接的方式编译test.cpp
g++ -o test test.cpp -L./addlib -ladd
```

#### g++(gcc)编译选项
- -shared: 指定生成动态链接库
- -static: 指定生成静态链接库
- -fPIC: 表示编译为位置独立的代码，用于编译共享库。目标文件需要创建成位置无关码，念上就是在可执行程序装载它们的时候，它们可以放在可执行程序的内存里的任何地方
- -L.: 表示要连接的库所在的目录
- -l: 指定链接时需要的动态库。编译器查找动态连接库时有隐含的命名规则，即在给出的名字前面加上lib，后面加上.a/.so来确定库的名称
- -Wall: 生成所有警告信息
- -ggdb: 此选项将尽可能的生成gdb的可以使用的调试信息
- -g: 编译器在编译的时候产生调试信息
- -c: 只激活预处理、编译和汇编,也就是把程序做成目标文件(.o文件)
- -Wl,options: 把参数(options)传递给链接器ld。如果options中间有逗号,就将options分成多个选项,然后传递给链接程序
