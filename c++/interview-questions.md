#### 关于动态申请内存
- 内存分配方式三种
  - 从静态存储区域分配: 内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在；全局变量，static变量
  - 在栈上创建: 在执行函数时，函数内局部变量的存储单元都可以在栈上创建
  - 用 malloc 或 new 申请内存之后，应该立即检查指针值是否为 NULL，防止使用指针值为NULL的内存，不要忘记为数组和动态内存赋初值

#### 进程和线程
- 调度: 线程作为调度和分配的基本单位，进程作为拥有资源的基本单位
- 并发性: 不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行
- 拥有资源: 进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源
- 系统开销: 创建撤消进程，系统都要为之分配和回收资源，系统的开销明显大于创建撤消线程多进程与多线程

#### C++ 指针攻破
指针是一个变量，专门存放内存地址，特点是能访问所指向的内存
指针本身占据了4个字节的长度
- int **ptr
- int (*ptr)[3]
- int *(*ptr)[4]
- ptr++: 指针ptr的值加上了 sizeof(int)
- ptr+=5: 将指针ptr的值加上 5 * sizeof(int)

#### 复制指针解析
- int (*func)(int *p);
  - (*func)()是一个函数，func是一个指向这类函数的指针，就是一个函数指针，这类函数具有int*类型的形参，返回值类型是 int
- int (*func)(int *p, int (*f)(int*));
  - func是一个指向函数的指针，这类函数具有int *和int (*)(int*)这样的形参。形参int (*f)(int*），f也是一个函数指针
- int (*func[5])(int *p);
  - func数组的元素是函数类型的指针，它所指向的函数具有int*类型的形参，返回值类型为int
- int (*(*func)[5])(int *p);
  - func是一个指向数组的指针，这个数组的元素是函数指针，这些指针指向具有int*形参，返回值为int类型的函数
- int (*(*func)(int *p))[5];
  - func是一个函数指针，这类函数具有int*类型的形参，返回值是指向数组的指针，所指向的数组的元素是具有5个int元素的数组

#### 函数指针详解
函数指针是指向一个函数入口的指针
一个函数指针只能指向一种类型的函数，即具有相同的返回值和相同的参数的函数
- 函数指针数组定义: void(*fun[3])(void*);  
- 相应指向类A的成员函数的指针: void (A::*pmf)(char *, const char *)
- 指向外部函数的指针: void (*pf)(char *, const char *)
- void strcpy (char * dest, const char * source)
- pf = strcpy

#### 野指针
- 指针变量没有被初始化。指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存
```c
  char *p = NULL;
  char *str = (char *) malloc(100);
```
- 指针p被free或者delete之后，没有置为NULL
- 指针操作超越了变量的作用范围
- 所指向的内存值对象生命期已经被销毁

#### 引用和指针有什么区别
- 引用必须初始化，指针则不必；引用初始化以后不能改变，指针可以改变其指向的对象
- 不存在指向空值的引用，但存在指向控制的指针
- 引用是某个对象的别名，主要用来描述函数和参数和返回值
- 而指针与一般的变量是一样的，会在内存中开辟一块内存
- 如果函数的参数或返回值是类的对象的话，采用引用可以提高程序的效率

#### C++ 中的 Const 用法
- char * const p;                                   // 指针不可改,也就说指针只能指向一个地址,不能更改为其他地址，修饰指针本身
- char const * p;                                   // 所指内容不可改,也就是说*p是常量字符串，修饰指针所指向的变量
- const char * const p ; char const * const p;      // 内容和指针都不能改


#### const常量与define宏定义的区别
- 编译器处理方式不同，define宏是在预处理阶段展开，生命周期止于编译期；只是一个常数、一个命令中的参数，没有实际的存在
- 类型和安全检查不同，define宏没有类型，不做任何类型检查，仅仅是展开；const常量有具体的类型，在编译阶段会执行类型检查
- 存储方式不同，define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存；const常量会在内存中分配（可以是堆中也可以是栈中）

#### 解释堆和栈的区别
- 栈区（stack）— 由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈
  - 在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量
  - 在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域，栈的大小是2M
  
- 堆区 (heap)— 一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收
  - 注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，需要程序员自己申请，并指明大小，在 c 中 malloc 函数在 C++ 中用 new 运算符
  - 一般是在堆的头部用一个字节存放堆的大小

#### 论述含参数的宏和函数的优缺点
- 函数调用时，先求出实参表达式的值，然后代入形参；而使用带参的宏只是进行简单的字符替换
- 函数调用是在程序运行时处理的，分配临时的内存单元；而宏展开是在编译时进行的，在展开时不进行内存分配，不进行值得传递处理，没有 "返回值" 概念
- 对函数中的形参和实参都要定义类型，类型要求一致，如不一致则进行类型转换；而宏不存在类型问题
- 调用函数只可得到一个返回值，而用宏则可以设法得到几个结果
- 实用宏次数多时，宏展开后源程序变长，没展开一次源程序增长，函数调用则不会
- 宏替换不占用运行时间，只占编译时间，而函数调用占用运行时间

#### C++的空类，默认产生哪些类成员函数
```cpp
{
  public:
    Empty();                            // 缺省构造函数
    Empty（const Empty& ）;             // 拷贝构造函数
    ~Empty();                           // 虚构函数
    Empty& operator(const Empty& )      // 赋值运算符
    Empty& operator&();                 // 取址运算符
    const Empty* operator&() const;     // 取址运算符 const
}
```

#### 类和结构体的区别
- 结构体在默认情况下的成员都是public的, 而类在默认情况下的成员是private的
- 结构体和类都必须使用new创建，struct保证成员按照声明顺序在内存在存储，而类不保证

#### C++ 四种强制类型转换
- const_cast 字面上理解就是去const属性，去掉类型的const或volatile属性
```cpp
struct SA {
  int k
};

const SA ra;

ra.k = 10;                      // 直接修改const类型，编译错误   
SA& rb =  const_cast<SA&>(ra);
rb.k = 10;                      // 可以修改
```
- static_cast 基本类型之间和具有继承关系的类型之间的转换
```cpp
int a;
double d = static_cast<double>(a);   // 基本类型转换

int &pn = &a;     
void *p = static_cast<void*>(pn);    // 任意类型转换为 void
```
- dynamic_cast 动态类型转换，运行时类型安全检查(转换失败返回NULL)
```cpp
class BaseClass {
  public: int m_iNum;
  virtual void foo () {};
};

class DerivedClass:BaseClass {
  public: char* szName[100];  
  void bar () {};
};

BaseClass* pb = new DerivedClass();

DerivedClass *p2 = dynamic_cast<DerivedClass *>(pb);
BaseClass* pParent = dynamic_cast<BaseClass*>(p2);
```
- reinterpreter_cast 转换的类型必须是一个指针、引用、算术类型、函数指针或者成员指针
```cpp
int DoSomething () {
  return 0;
};

typedef void(*FuncPtr) () {};
FuncPtr funcPtrArray[10];
funcPtrArray[0] = reinterpreter_cast<FuncPtr>(&DoSomething);
```
#### memset ,memcpy 和strcpy 的根本区别
- memset用来对一段内存空间全部设置为某个字符，一般用在对定义的字符串进行初始化为' '或''；它对较大的结构体或数组进行清零操作的一种最快方法
```cpp
char temp[30];
memset(temp, '\0', sizeof(temp));
```
- memcpy用来做内存拷贝，你可以拿它拷贝任何数据类型的对象，可以指定拷贝的数据长度
- strcpy就只能拷贝字符串了，它遇到'\0'就结束拷贝
```cpp
  char a[100], b[50];
  strcpy(a, b);
```

#### 将 "引用" 作为函数参数
- 传递引用给函数与传递指针的效果是一样的
- 使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作，当参数数据较大时，引用传递参数的效率和所占空间都好
- 如果使用指针要分配内存单元，需要重复使用 "*指针变量名" 形式进行计算，容易出错且阅读性较差

#### 在C++程序中调用C编译后的函数，为什么要加extern C的声明
因为C++支持函数重载，而C不支持函数重载，函数被C++编译后在库中的名字与C语言的不同

#### Template
- Template可以独立于任何特定的类型编写代码，是泛型编程的基础
- 当我们编写的类和函数能够多态的用于跨越编译时不相关的类型时，用Template
- 模板主要用于STL中的容器,算法,迭代器等以及模板元编程
- C++ 的 template 是实现在库设计和嵌入式设计中的关键，能实现抽象和效率的结合
- 同时template还能有效地防止代码膨胀

#### why Template class
- 可用来创建动态增长和减小的数据结构
- 它是类型无关的，因此具有很高的可复用性
- 它在编译时而不是运行时检查数据类型，保证了类型安全
- 它是平台无关的，可移植性
- 可用于基本数据类型

#### static
- 函数体内作用范围为该函数体，该变量内存只被分配一次，具有记忆能力
- 在模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其它函数访问
- 在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内
- 在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝
- 在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量

#### 头文件的作用是什么
- 通过头文件来调用库功能
- 头文件能加强类型安全检查

#### extern C
因为C++支持函数重载，而C不支持函数重载，函数被C++编译后在库中的名字与C语言的不同
void foo(int x, int y)
该函数被C编译器编译后在库中的名字为_foo
C++编译器则产生像_foo_int_int之类的名字。 C++提供extern C来解决名字匹配问题

- todo 26
