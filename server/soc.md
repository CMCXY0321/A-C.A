#### 0×02 需求
从我们要从收集到日志数据中，分析各种可能存在威胁，按照高中低危进行报警，并统计威胁数据，进行报警与后续动作
> SRC_IP, DST_IP, LEVEL, TYPE
> 192.168.1,192.168.6, high, php_injection
> 192.168.1,192.168.6, middle, xss_injection
> 192.168.1,192.168.6, low, sql_injection

整个系统要做的就是
> 数据收集: 生产中很多服务器的日志和状态数据，我们都可以拿来分析; 如果是nginx服务器，我们可以通过访问日志发现访问中的威胁，如果部署有HIDS，我们可以分析单机服务器的状态，并与长期聚合的白名单进行比对，发现威胁
> 数据清洗: 实际我们收集了大量的各种日志数据，这些数据，我们不能直接拿来用，初级阶段的日志分析和简单查找可以做到，之后，我们需要对数据的格式进行整形，如果进行威胁分析，就要把大量不关键的信息清洗掉
> 威胁分析: 我们的数据在先期经过了整型和规范化后，可以把数据与我们的威胁特征库进行比较分析，用我们积累的威胁特征库来威胁判断，发现数据中是否存在异常的威胁行为存在
> 威胁展示: 经过数据的清洗与威胁初步判断，我们找出了，存在于日常中日志中的威胁行为，我们需要对这些数据，按优先级，威胁高低程度显现，给安装安全运维人员使用
> 威胁报警: 在实际的工作中，会有各种威胁报警产生，但是真正危害到系统的关键性威胁，是有一个优先层级的，我们往往把优先级高，危害大的威胁行为，第一时间通知管理人员

#### 0×03 数据收集与存储
数据存储:
> Syslog服务器: Syslog是基于UDP协议的，很多设备都支持syslog日志传送，生产中有很多nginx为基础的web应用，nginx也可以发送syslog格式的日志
> ES数据库服务器集群: ES对于存JSON形式的数据非常友好，我们可以把syslog数据进行数据整形存到ES中
> Kafka队列: 有时数据IO特别大时，需要一个缓存来存数据，然后再消费到ES或是ClickHouse中
> ClickHouse: ClickHouse支持大数据存储，可以支持SQL查询
> MongoDB: 这种KV数据库几乎也是要用的，用于存放共享配置信息
> Graylog数据网关: 如果我们支持通过HTTP接口去ES中取数据，要处理跨index的查询，而实际当中，如果可以把ES的操作按业务单元再抽象出一层，把对业务数据的操作，归并成大类的REST API操作，会让处理逻辑更清晰，更好维护，这种情况下，Graylog提供的REST服务就为我们解决了这个问题，Graylog提供了原始数据“流”数据组织的跨越

数据收集:
> NxLog: Nxlog是支持跨平台的系统级日志收集，我们可以在Windows好部署Nxlog解决特定日志的收集问题
> CatKafka: catkafka可以把本地落地的日起文本推送到kafka队列中，然后从队列中消费到ES或是ClickHouse中
> Logger: 这个就是把文本放到syslog服务器接受端口
> Filebeat: 把文本内容发到ES中

#### 0×04 威胁分析处理
> 数据源: 没有数据源无从进行分析
> 判断策略: 对威胁和异常的定义，是我们判断的主要依据，实际生产中，有各种威胁，这种威胁的定义都是不一样，我们只有有这种对异常的判断依据，才能分析出什么是问题行为
> 黑白名单: 威胁报警噪音，各种系统和设备的误报其实是一直存在，我们实际事况也很复杂，应对误报比较有效的一种方式，就是构建黑白名单机制，把明显的误报都放到白名单里，把特别需要注意的，出现过问题的服务列表放到黑名单里

数据分析:
> 架构设计: 整体的架构设计很明了，基于ES和ClickHouse为数据存储核心，围绕核心写子系统
> 概要设计: 如果非系统的概要级描述， 从技术角度来看，我们采用插件方式组织模块，从业务上来讲，SQL注入和PHP注入的关联性是不大的，我们采用插件的方式也是为了解开模块间的耦合关系
> 单元插件设计: 体现出单体设计大不同，可以从单体类的接口设计和目录构成来区分

#### 0×05 模块单体设计
单体设计:
模块对象接口设计：为了使用类工厂集中调度模块，我们预定了插件模块必须要有接口函数
```cpp
/* 定义单体可处理的输入数据 */
class input_data {
  string src_ip,
  string dst_ip,
  string payload
};

/* 定义单体输出的数据型态 */
class output_data {
  string src_ip,
  string dst_ip,
  string payload,
  int level
};

class xxx_Injection {
  vritual int Init(void);                           // 负责所有相关外部数据资源的获取和黑白名单的设置。
  virtual output_data* main(input_data *message);   // 主要的威胁判断和特征判断。
  virtual int fin(void);                            // 释放相关资源
};
```
目录构成设计:
> lib、src、data、config文件夹，Makefile、run.sh、logs三个文件
> lib文件夹: 所有的特征库都在这里，比如libInjection这个库
> src文件夹: 插件的源代码
> data文件夹: 单体测试用的CSV文件
> config文件夹: 黑白名单配置文件
> Makefile文件: 单体配置文件
> run.sh文件: 运行脚本
> logs文件: 调试日志

#### 0×06 威胁报表与报警
威胁输出格式
> SRC_IP, DST_IP, LEVEL, TYPE
> 192.168.1,192.168.6, high, php_injection
> 192.168.1,192.168.6, middle, xss_injection
> 192.168.1,192.168.6, low, sql_injection

如果是在ClickHouse生产系统中创建威胁表格要比这个多, 字段和展现的数据聚合是有关系的
> SRC_IP: 攻击IP，是谁发起的IP，我们可以对应IP在表中产生地理位置信息，典型的报表形式就是用于地图跑。攻击IP是可以威胁情报进行比对的
> DST_IP: 被攻击IP，具体那个服务器被攻击，一般的公司都有服务器管理的CMDB数据库，可以在生成报告时，直接找到对应的IDC、机房、管理员
> LEVEL: 威胁级别，高中代危，看黑白名单和特征库的定级
> TYPE: 具体是什么威胁，比如：SQL注入、XSS注入、PHP注入

威胁报告的形式
> 邮件: 每天早上发送昨天的攻击总结日报告、周报告、月报告等。被威胁IP的top10、被攻击总数top10、威胁聚合分布
> 实时报告: 提供实时查询接口，直接给出ClickHouse威胁情报的聚合信息，实时查询挂在墙上
