#### 内存分为五个部分：
- BSS段 (Block Started by Symbol)
  - 用来存放程序中未初始化的全局变量的内存区域
- 数据段 (data segment)
  - 用来存放程序中已初始化的全局变量的内存区域
- 代码段 (text segment)
  -用来存放程序执行代码的内存区域
- 堆 (heap）
  - 用来存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减
  - 当进程调用malloc分配内存时，新分配的内存就被动态添加到堆上，当进程调用free释放内存时，会从堆中剔除
- 栈 (stack）
  - 存放程序中的局部变量（但不包括static声明的变量，static变量放在数据段中）
  - 同时，在函数被调用时，栈用来传递参数和返回值。由于栈先进先出特点
  - 所以栈特别方便用来保存/恢复调用现场

#### 栈详解
- 当在函数或块内部声明一个局部变量时，如：int nTmp; 系统会判断申请的空间是否足够，足够，在栈中开辟空间，提供内存；不够空间，报异常提示栈溢出
- 当调用一个函数时，系统会自动为参数当局部变量，压进栈中，当函数调用结束时，会自动提升堆栈。（可查看汇编中的函数调用机制）

#### 栈的大小
栈是有一定大小的，通常情况下，栈只有2M，不同系统栈的大小可能不同
在linux中，查看进程/线程栈大小，命令: ulimit  -s
- ulimit  -s
- 8192

我的系统中栈大小为 8192, 有些系统为 10240, 具体查看自已系统栈大小

#### 设置栈大小:
- 临时改变栈大小: ulimit  -s  10240
- 开机设置栈大小: 在/etc/rc.local中加入 ulimit  -s  10240
- 改变栈大小: 在/etc/security/limits.conf中加入
* soft stack 10240

#### 注意事项:
- 对于局部变量, 尽量不定义大的变量, 如大数组 (大于2*1024*1024字节)
```c
char  buf[2*1024*1024];                         // 可能会导致栈溢出
```
- 对于内存较大或不知大小的变量, 用堆分配, 局部变量用指针, 注意要释放
```c
char*  pBuf = (char*)malloc(2*1024*1024);       // char* 为局部变量  malloc的内存在堆
free(pBuf);
```
- 或定义在全局区中, static变量或常量区中 
```c
static char buf[2*1024*1024];
```
#### 栈的生长方向
栈的生长方向和存放数据的方向相反，自顶向下

#### 堆详解
堆 (heap): 是用来存放动态申请或释放的区域。需要程序员分配和释放，系统不会自动管理，如果用完不释放，将会造成内存泄露，直到进程结速后，系统自动回收

#### 申请和释放
```c
int  function () {
  char *pTmp = (char*) malloc(1024);    // malloc在堆中分配1024字节空间
  free(pTmp);	                          // free为手动释放堆中空间
  pTmp = NULL;	                        // 防止pTmp变野指针误用
}
```

#### 堆的生长方向
堆是由低地址向高地址生长的

#### 堆的注意事项
- 释放问题: 分配了堆内存，一定要记得手动释放，否则将会导致内存泄露
- 碎片问题: 如果频繁地调用内存分配和释放，将会使堆内存造成很多内存碎片，从而造成空间浪费和效率低下
- 超堆大小问题: 如果申请内存超过堆大小，会出现虚拟内存不足等问题
- 分配是否成功问题: 申请内存后，都在判断内存是否分配成功，分配成功后才能使用，否则会出现段错误
```c
char * pTmp = (char*) malloc(102400);

if(pTmp == 0) {
  return false;
}
```
- 释放后野指针问题: 释放指针后，一定要记得把指针的值设置成NULL，防止指针被释放后误用
```c
free(pTmp);
pTmp = NULL; // 防止变野指针
```
- 多次释放问题



