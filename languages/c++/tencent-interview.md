#### C 和 C++ 的特点与区别
- C语言特点:
  - 作为一种面向过程的结构化语言，易于调试和维护
  - 表现能力和处理能力极强，可以直接访问内存的物理地址
  - C语言实现了对硬件的编程操作，也适合于应用软件的开发
  - C语言还具有效率高，可移植性强等特点
  
- C++语言特点:
  - 在C语言的基础上进行扩充和完善，使C++兼容了C语言的面向过程特点，又成为了一种面向对象的程序设计语言
  - 可以使用抽象数据类型进行基于对象的编程
  - 可以使用多继承、多态进行面向对象的编程
  - 可以担负起以模版为特征的泛型化编程
  
#### C++ 与 C 语言的本质差别
- 在于C++是面向对象的
- 而C语言是面向过程的

#### C++ 的多态
##### C++的多态性用一句话概括:
- 在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数
- 如果对象类型是派生类，就调用派生类的函数
- 如果对象类型是基类，就调用基类的函数
- 用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数
- 存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针
- 虚表是和类对应的，虚表指针是和对象对应的
- 多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性
- 多态用虚函数来实现，结合动态绑定
- 纯虚函数是虚函数再加上 = 0
- 抽象类是指包括至少一个纯虚函数的类

##### 虚函数实现
每一个含有虚函数（无论是其本身的，还是继承而来的）的类都至少有一个与之对应的虚函数表，其中存放着该类所有的虚函数对应的函数指针
- B的虚函数表中存放着B::foo和B::bar两个函数指针
- D的虚函数表中存放的既有继承自B的虚函数B::foo，又有重写（override）了基类虚函数B::bar的D::bar，还有新增的虚函数D::quz
```cpp
strcut B {
  long b;
  virtual void foo () {}
  virtual void bar () {}
}

struct D : public B {
  long d;
  virtual void bar () {}
  virtual void quz () {}
}
```

```cpp
void test (B* pb) {
  pb->bar();
}
```

##### 虚函数表构造过程
从编译器的角度来说，B的虚函数表很好构造，D的虚函数表构造过程相对复杂

##### C 和 C++ 内存分配问题
- C语言编程中的内存基本构成
  - C的内存基本上分为4部分：静态存储区、堆区、栈区以及常量区
    - 栈 ——由编译器自动分配释放；
    - 堆 ——一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收；
    - 全局区（静态区）——全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域（C++中已经不再这样划分），程序结束释放；
    - 另外还有一个专门放常量的地方，程序结束释放；
      - 函数体中定义的变量通常是在栈上
      - 用malloc, calloc, realloc等分配内存的函数分配得到的就是在堆上
      - 在所有函数体外定义的是全局量
      - 加了static修饰符后不管在哪里都存放在全局区（静态区）
      - 在所有函数体外定义的static变量表示在该文件中有效，不能extern到别的文件用
      - 在函数体内定义的static表示只在该函数体内有效
      - 另外，函数中的 "adgfdf" 这样的字符串存放在常量区

- C++编程中的内存基本构造
  - 在C++中内存分成5个区，分别是堆、栈、全局/静态存储区、常量存储区和代码区
    - 栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清楚的变量的存储区，里面的变量通常是局部变量、函数参数等
    - 堆，就是那些由new分配的内存块，他们的释放编译器不去管，由应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收
    - 全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区
    - 常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改）
    - 代码区（.text段），存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区）

##### 内存模型组成部分：自由存储区，动态区、静态区
根据c/c++对象生命周期不同，c/c++的内存模型有三种不同的内存区域，即：自由存储区，动态区、静态区
- 自由存储区: 局部非静态变量的存储区域，即平常所说的栈
- 动态区: 用new ，malloc分配的内存，即平常所说的堆
- 静态区: 全局变量，静态变量，字符串常量存在的位置

##### 正在运行着的C编译程序占用的内存分为5个部分：代码区、初始化数据区、未初始化数据区、堆区 和栈区
- 代码区（text segment）:代码区指令根据程序设计流程依次执行，对于顺序指令，则只会执行一次（每个进程），如果反复，则需要使用跳转指令，如果进行递归，则需要借助栈来实现
- 全局初始化数据区/静态数据区（Data Segment）: 只初始化一次
- 未初始化数据区（BSS）: 在运行时改变其值
- 栈区（stack）: 由编译器自动分配释放，存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈
- 堆区（heap）: 用于动态内存分配

##### 协程
定义: 协程是一种用户态的轻量级线程
- 协程拥有自己的寄存器上下文和栈
- 协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈

##### CGI的了解
CGI：通用网关接口（Common Gateway Interface）是一个Web服务器主机提供信息服务的标准接口:
- 通过CGI接口，Web服务器就能够获取客户端提交的信息
- 转交给服务器端的CGI程序进行处理，最后返回结果给客户端

CGI通信系统的组成是两部分: 
- 是html页面，就是在用户端浏览器上显示的页面
- 则是运行在服务器上的Cgi程序

#### 进程间通信方式和线程间通信方式
- 管道(pipe): 管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系
- 信号量(semophore): 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段
- 消息队列(message queue): 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点
- 共享内存(shared memory): 共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信
- 套接字(socket): 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。

#### 线程间通信方式
- 全局变量
- Messages消息机制
- CEvent对象（MFC中的一种线程通信对象，通过其触发状态的改变实现同步与通信）

#### TCP握手与释放
##### 握手
- 第一次握手: 主机A发送握手信号 syn ＝ 1 和 seq = x（随机产生的序列号）的数据包到服务器，主机B由SYN=1知道，A要求建立联机
- 第二次握手: 主机B收到请求后要确认联机信息，向A发送syn = 1，ack = x（x是主机A的Seq）+1，以及随机产生的确认端序列号seq = y的包
- 第三次握手: 主机A收到后检查ack是否正确（ack = x + 1），即第一次发送的seq + 1，若正确，主机 A 会再发送ack = y + 1，以及随机序

##### 列号seq=z，主机B收到后确认ack值则连接建立成功

##### 挥手
由于TCP连接是全双工的，因此每个方向都必须单独进行关闭

- TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送
- 服务器收到这个FIN，发回一个ACK，确认序号为收到的序号加1
- 和SYN一样，一个FIN将占用一个序号
- 服务器关闭客户端的连接后，再发送一个FIN给客户端
- 客户段收到服务端的FIN后，发回ACK报文确认，并将确认序号设置为收到序号加1

##### 握手，挥手过程中各状态介绍
- 3 次握手过程状态
  - LISTEN: 这个也是非常容易理解的一个状态，表示服务器端的某个SOCKET处于监听状态，可以接受连接
  - SYN_SENT: 当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文
  - SYN_RCVD: 这个状态与SYN_SENT遥想呼应这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态
  - ESTABLISHED: 这个容易理解了，表示连接已经建立
- 4 次挥手过程状态
  - FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文
  - FIN_WAIT_2: 上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接
  - TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了
  - CLOSING(比较少见): 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态
  - CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭
  - LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文

##### http和https的区别
HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全

##### HTTP和HTTPS协议是应用层协议
- HTTP 是应用层协议，并且HTTPS是在HTTP协议基础上添加SSL等加密策略后的协议
- TLS / SSL中使用了非对称加密，对称加密以及HASH算法

#### Http协议
##### HTTP协议和TCP协议之间的区别联系
- TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据
- HTTP的默认端口号是80，TCP/IP协议通信编程时端口号需要自己指定（例如socket编程）
- HTTP协议是在TCP/IP协议基础上实现的，即HTTP数据包是经过TCP/IP协议实现传输的
- HTTP是无状态的短连接协议，TCP是有状态的长连接协议

##### HTTP是在有状态长连接TCP/IP协议的基础上实现的，为什么却是无状态短连接协议
- HTTP协议每次请求结束就会自动关闭连接，这样就变成了短连接
- 短连接又导致了该次请求相关信息的丢失，也就造成了HTTP协议对于前期事务处理没有记忆能力，故为无状态协议

##### HTTP协议其完整的工作过程可分为四步
- 连接：首先客户机与服务器需要建立连接（由TCP/IP握手连接实现）
- 请求：建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容
- 应答：服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容
- 关闭：当应答结束后，浏览器和服务器关闭连接，以保证其他浏览器可以与服务器进行连接

##### 更完整的过程
--> 域名解析
--> 发起 TCP 的 3 次握手
--> 建立 TCP 连接后发起 http 请求
--> 服务器响应 http 请求，浏览器得到 html 代码 
--> 浏览器解析 html 代码，并请求 html 代码中的资源（如js、css、图片等）
--> 浏览器对页面进行渲染呈现给用户

#### Https协议
HTTPS 握手过程包括五步
- 浏览器请求连接
- 服务器返回证书：证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息
- 浏览器收到证书后作以下工作：
  - 验证证书的合法性
  - 生成随机（对称）密码，取出证书中提供的公钥对随机密码加密
  - 将之前生成的加密随机密码等信息发送给网站
- 服务器收到消息后作以下的操作：
  - 使用自己的私钥解密浏览器用公钥加密后的消息，并验证HASH是否与浏览器发来的一致
  - 使用加密的随机对称密码加密一段消息，发送给浏览器
- 浏览器解密并计算握手消息的HASH：如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密

##### HTTPS协议、SSL、和数字证书的关系介绍
HTTPS协议，所有的消息都是经过SSL协议方式加密，而支持加密的文件正是数字证书
- SSL
  - SSL常用的加密算法：对称密码算法、非对称密码算法、散列算法
  - 需要注意的是非对称加解密算法的效率要比对称加解密要低的多
  - SSL在握手过程中使用非对称密码算法来协商密钥，实际使用对称加解密的方法对http内容加密传输
- 数字证书
  - 数字证书是用于在INTERNET上标识个人或者机构身份的一种技术手段，它通过由一些公认的权威机构所认证

#### 虚拟内存的概念与介绍
虚拟内存的实现有以下三种方式:
- 请求分页存储管理
- 请求分段存储管理
- 请求段页式存储管理

#### 虚拟内存的意义
- 虚拟内存可以使得物理内存更加高效
- 使用虚拟地址可以使内存的管理更加便捷
- 为了安全性的考虑

#### 单链表的反转算法
思想: 创建3个指针，分别指向上一个节点、当前节点、下一个节点，遍历整个链表的同时，将正在访问的节点指向上一个节点，当遍历结束后，就同时完成了链表的反转
```cpp
ListNode* ReverseList(ListNode* pHead) {
    ListNode *p,*q,*r;
    if (pHead==NULL || pHead->next==NULL) {
        return pHead;
    } else {
        p=pHead;
        q=p->next;
        pHead->next=NULL;
        while (q!=NULL) {
            r=q->next;
            q->next=p;
            p=q;
            q=r;
        }

        return p;
    }
}
```

#### 红黑树以及其查找复杂度
- 红黑树来源于二叉搜索树，其在关联容器如map中应用广泛，主要优势在于其查找、删除、插入时间复杂度小，但其也有缺点，就是容易偏向一边而变成一个链表
红黑树的五个性质：

- 节点是红色或黑色
- 根节点是黑色
- 每个叶节点（指树的末端的NIL指针节点或者空节点）是黑色的
- 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
- 从任一节点到其每个尾端NIL节点或者NULL节点的所有路径都包含相同数目的黑色节点
- 一棵由n个结点随机构造的二叉查找树的高度为lgn
- 二叉查找树的一般操作的执行时间为O(lgn)

#### 左旋右旋
- 部分结点颜色，重新着色
- 调整部分指针的指向，即左旋、右旋

左旋代码实现，分三步:
- 开始变化，y的左孩子成为x的右孩子；
- y成为x的父结点；
- x成为y的左孩子；

#### KPM字符串匹配
- KMP匹配算法代码实现:
```c
int KmpSearch(char* s, char* p)  
{  
    int i = 0;  
    int j = 0;  
    int sLen = strlen(s);  
    int pLen = strlen(p);
    
    while (i < sLen && j < pLen)  
    {  
        // 如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++      
        if (j == -1 || s[i] == p[j]) {  
            i++;  
            j++;  
        } else {  
            // j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]      
            // next[j]即为j所对应的next值        
            j = next[j];  
        }  
    }
    
    if (j == pLen) {
        return i - j;
    } else { 
        return -1;
    }
} 
```

- next数组求取
最重要的就是：一旦不匹配，模式串不是向后移动一位，而是根据前面匹配信息移动多位
- 寻找前缀后缀最长公共元素长度
- 求next数组

```cpp
string T;  // T 为模式串
cin>>T;
int len=T.size();
queue<int> MaxLen;
vector<int> next;
MaxLen.push(0);  // 第一个元素都设为 0

for (int i = 1; i < len; i++) {
  int k=1,
      maxLen=0;

  while(k<=i) {
    if(T.substr(0,k) == T.substr(i-k+1,k)) {
      maxLen=k;
    }

    k++;
  }

  MaxLen.push(maxLen);
}

cout<<endl;
next.push_back(-1); // 第一个元素都设为-1

while (MaxLen.size()>1) {
  int temp=MaxLen.front();
  next.push_back(temp);
  MaxLen.pop();
  cout<<temp<<' ';
}
```

#### TCP超时等待、重传以及流量控制

#### 数据库引擎
- 数据库引擎是用于存储、处理和保护数据的核心服务。利用数据库引擎可控制访问权限并快速处理事务，从而满足企业内大多数需要处理大量数据的应用程序的要求
- 数据库引擎就是一段用于支撑所有数据库操作的核心程序，就如名称一样，是一个车的引擎功能

##### 常见的数据库引擎有
- Microsoft JET (Joint Engineering Technologe) 用于Access和VB的内嵌数据库功能的核心元素；
- ODBC（Open DataBase Connectivity，开放数据库互连）是由Microsoft定义的一种数据库访问标准，它提供一种标准的数据
- OLE DB是Microsoft开发的最新数据库访问接口，Microsoft将其定义为ODBC接班人
- MYSQL支持三个引擎：ISAM、MYISAM和HEAP。另外两种类型INNODB和BERKLEY（BDB）也常常可以使用
  - ISAM执行读取操作的速度很快，而且不占用大量的内存和存储资源。ISAM的两个主要不足之处在于，它不 支持事务处理，也不能够容错
  - MyISAM是MySQL的ISAM扩展格式和缺省的数据库引擎MYISAM。除了提供ISAM里所没有的索引和字段管理的大量功能
  - HEAP允许只驻留在内存里的临时表格。驻留在内存里让HEAP要比ISAM和MYISAM都快，但是它所管理的数据是不稳定的

##### 数据库索引
定义: 数据库索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息

##### 数据库索引作用:
- 大大加快 数据的检索速度，这也是创建索引的最主要的原因
- 保证数据库表中每一行数据的唯一性
- 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义
- 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间
- 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能

##### 数据库索引缺陷:
- 表的增删改查、创建索引和维护索引要耗费时间
- 索引需要占物理空间

#### 数据库索引的两个特征
- 唯一性索引
  - 唯一性索引保证在索引列中的全部数据是唯一的，不会包含冗余数据
- 复合索引
  - 复合索引就是一个索引创建在两个列或者多个列上，搜索时需要两个或者多个索引列作为一个关键值

索引分为聚簇索引和非聚簇索引两类
- 聚簇索引是按照数据存放的物理位置为顺序的，其多个连续行的访问速度更快；
- 非聚簇索引是按照数据存放的逻辑位置为顺序的，其单行访问速度更快；

#### 局部性原理
- 局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中
- 磁盘预读：正是由于局部性原理以及数据存储磁盘的读写速度慢的原因，每次对数据库进行读取都不是按需读取，而是读取多于需求数据区域内的数据到内存，用于后续使用，提高写读取数据速度

#### B-/+Tree结构的数据库索引的性能分析
##### B树索引结构
数据库系统的设计者巧妙利用了磁盘预读原理，将B树的一个节点的大小设为等于一个页，这样每个节点只需要一次 I/O 就可以完全载入
  - 每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页
  - B-Tree中一次检索最多需要h-1次I/O（磁盘IO不包括根节点，因为根节点常驻内存），渐进复杂度为O(h)=O(logdN)

##### B+树的索引结构
B+树则适当牺牲检索的时间复杂度（都必须检索到叶子结点），但改善了节点插入和删除的时间复杂度（类似用链表改善数组的效果），所以 B+ 树属于一种折中选择





