## jvm
### 原理
- JVM屏蔽了与具体平台相关的信息，使得JAVA程序只需编译成适应JVM，可以在JVM上运行的目标代码（.class）就行，JVM再负责解释成具体平台的机器指令执行
- 同时，JVM还会进行安全检查，是java程序的安全检验引擎

### 结构
- 类加载器
- 执行引擎
- 运行时数据区域

#### 类加载器
具体作用就是将.class文件加载到jvm虚拟机中去，程序就可以正确运行了。但是，jvm启动的时候，并不会一次性加载所有的.class文件，而是根据需要去动态加载
- 当前类加载器首先检查自己的加载清单，如果存在该类，则返回之
- 如果没找到，委托父类加载器去加载；父类加载器重复动作1，递归至祖宗bootstrap ClassLoder（我靠，bootstrap，还以为是前端框架呢。bootstrap，引导之意）
- 都没有，仍然由当前类加载器加载，并纳入自己缓存中

- 所谓的安全，是指java的核心类不被用户自己编写的类所替换
- 由于核心类在虚拟机初始化时就已加载，而每次加载类前先检查是否存在，所以可以避免核心类被替换

- Bootstrap class loader：
  - 当运行 java 虚拟机时，这个类加载器被创建，它负责加载虚拟机的核心类库，如 java.lang.* 等
  - 例如 java.lang.Object 就是由根类加载器加载的。需要注意的是，这个类加载器不是用 java 语言写的，而是用 C/C++ 写的

- Extension class loader:
  - 这个加载器加载出了基本 API 之外的一些拓展类

- AppClass Loader（SystemAppClass）:
  - 加载应用程序和程序员自定义的类

#### 执行引擎
执行java编译好的字节码，或者执行本地方法

#### 运行时数据区域
JVM 运行时数据区域 (JVM Runtime Area) 其实就是指 JVM 在运行期间，其对JVM内存空间的划分和分配
```
Program Counter (PC) Register：程序计数器
Java Virtual Machine Stacks：Java虚拟机栈
Heap Memory：堆内存
Method Area：方法区
Run-time Constant Pool：运行时常量池
Native Method Stacks：本地方法栈
```
```
堆内存
Java虚拟机栈
本地方法栈
程序计数器
方法区
```

#### 线程的角度
- 线程私有
  - 程序计数器 Java虚拟机栈 本地方法栈，生命周期与线程一致
- 线程共享
  - 堆内存，方法区，运行时常量池，生命周期与JVM一致
  - 这3个内存区域是不需要进行垃圾回收的。因为他们的生命周期是和线程同步的，随着线程的销毁，他们占用的内存会自动释放
- 存储内容
  - 方法区和常量池存储类的信息
  - 堆内存存储对象信息
  - 程序计数器，Java虚拟机栈，本地方法栈存储线程的信息
- 堆内存、方法区和运行时常量
  - 方法区的作用是存储 Java 类的结构信息，当我们创建对象实例后，对象的类型信息存储在方法区之中，实例数据存放在堆内存中
  - 运行时常量池是方法区的一部分，所以也是全局共享的。其作用是存储 Java 类文件常量池中的符号信息
  - class 文件中存在常量池(非运行时常量池)，其在编译阶段就已经确定
  - JVM 规范对 class 文件结构有着严格的规范，必须符合此规范的 class 文件才会被 JVM 认可和装载
- 直接内存
  - 直接内存并不是JVM管理的内存，而是JVM以外的机器内存
  - JDK中有一种基于通道（Channel）和缓冲区（Buffer）的内存分配方式，将由C语言实现的native函数库分配在直接内存中，用存储在JVM堆中的DirectByteBuffer来引用




